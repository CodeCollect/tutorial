# \#Define

\#define 最常见的用法是为数值命名一个符号，本文将介绍 \#define 更多的用途。首先，观察一下它的正式描述：

```c++
#define name stuff
```

有了这条指令以后，每当有符号 name 出现在这条指令后面时，预处理器就会把它替换成 stuff 。

替换文本并不仅限于数值字面值常量。使用 \#define 指令，可以把**任何**文本替换到程序中。这里有几个例子：

```c++
#define reg         register
#define do_forever  for(;;)
#define CASE        break;case
```

第一个定义知识为关键字 register 创建了一个简短的别名。这个较短的别名使各个声明更容易通过制表符进行排列。第二个声明用一个更具描述性的符号来代替一种用于实现无限循环的 for 语句类型。最后一个声明定义了一种简短记法，以便在 switch 语句中使用。它自动地把一个 break 放在每个 case 之前，使得 switch 语句看上去更像其他语言的 switch 语句。

## 宏

\#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为**宏（ macro ）**。下面使宏的声明方式：

```c++
#define name(parameter-list) stuff
```

其中， parameter-list (参数列表)是一个由逗号分隔的符号列表，它们可能出现在 stuff 中。参数列表的左括号必须要与 name 紧邻。如果两者之间又任何空白存在，参数列表就会被解释为 stuff 的一部分。

当宏被调用时，名字后面是一个由逗号分隔的值的列表，每个值都与宏定义中的一个参数相对应，整个列表用一对括号包围。当参数出现在程序中时，与每个参数对应的实际值都将被替换到 stuff 中。

这里有一个宏，它接受一个参数：

```c++
#define SQUARE(x) x * x
```

如果在上述声明之后，把 `SQUARE(5)` 置于程序中，预处理器就会用下面这个表达式替换上面的表达式： `5 * 5` 。

但是这个宏存在一个问题。观察下面的代码段：

```c++
a = 5;
printf("%d\n", SQUARE(a + 1));
```

乍一看，可能觉得这段代码将打印 36 这个值。事实上，它将打印 11。想知道为什么？请观察被替换的宏文本。参数 x 被文本 a + 1 替换，所以这条语句实际上变成了 `printf("%d\n", a + 1 * a + 1);` 。现在问题清楚了：由替换产生的表达式并没有按照预想的次序进行求值。

在宏定义中加上两个括号，这个问题便很轻松地解决了： `#define SQUARE(x) (x) * (x)` 。在前面那个例子中，预处理器现在将用下面这条语句执行替换，从而产生预期的结果： `printf("%d\n", (a + 1) * (a + 1));` 。

这里有另一个宏定义。

```c++
#define DOUBLE(x) (x) + (x)
```

定义中使用了括号，用于避免前面出现的问题。但是这个宏，可能会出现另外一个不同的错误。下面这段代码将打印出什么值？

```c++
a = 5;
printf("%d\n", 10 * DOUBLE(a));
```

看上去，它好像将打印 100 ，但事实上它打印的是 55 。再一次，通过观察替换产生的文本，能够发现问题所在： `printf("%d\n", 10 * (a) + (a))` 。乘法运算在宏所定义的加法运算之前执行。这个错误很容易修正：在定义宏时，只要在整个表达式两边加上一对括号就可以了。 `#define DOUBLE(x) ((x) + (x))` 。

所有用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时，由于参数中的操作符或邻近的操作符之间不可预料的相互作用。

下面是一对有趣的宏：

```c++
#define repeat      do
#define until(x)    while(!(x))
```

这两个宏创建了一种“新”的循环，其工作过程类似于其他语言中的 repeat/until 循环。它按照下面这种方式使用：

```c++
repeat {
    statements
} until(i >= 10);
```

预处理器将用下面的代码进行替换：

```c++
do {
    statements
} while(!(i >= 10));
```

表达式 `1 >= 10` 两边的括号用于确保在 `!` 操作符执行之前先完成这个表达式的求值。

创建一套 \#define 宏，用一种看上去很像其他语言的方式编写 c/cpp 程序是完全可能的。在绝大多数情况下，应该避免这种诱惑，因为这样编写出来的程序使其他 c/cpp 程序员很难理解。他们必须时常查阅这些宏的定义以便弄清实际代码是什么意思。即使每个和这个项目生命周期各个阶段相关的人都熟悉那种被模仿的语言，这个技巧仍然可能产生混淆，因为准确地模仿其他语言的各个方面是极其困难的。
